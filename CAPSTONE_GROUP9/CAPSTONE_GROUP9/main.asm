//LCD COMMANDS
.EQU CLR_SCRN = 0X01	//CLEAR LCD SCREEN
.EQU CURSRGHT = 0X06	//SHIFT THE CURSOR RIGHT
.EQU SHFTLEFT = 0X07	//SHIFT THE DISPLAY LEFT
.EQU TOP_CELL = 0X80	//1ST ROW FIRST CELL
.EQU BOT_CELL = 0XC0	//2ND ROW, FIRST CELL

//SCORE RAM
.EQU HUNDREDS = $100	;memory location for hundred place
.EQU TENS = $102		;memory location for tens place
.EQU ONES = $103		;memory location for ones place

//CLOCK CONFIG
.EQU CLK = (1<<WGM12 | 1<<CS12)	//CTC MODE (PAGE 297-298) WITH PRESCALE 256

//LCD MNUEMONICS
.EQU LCD_DPRT = PORTD	;LCD DATA PORT
.EQU LCD_DDDR = DDRD	;LCD DATA DDR
.EQU LCD_DPIN = PIND	;LCD DATA PIN

.EQU LCD_CPRT = PORTB	;LCD COMMANDS PORT
.EQU LCD_CDDR = DDRB	;LCD COMMANDS DDR
.EQU LCD_CPIN = PINB	;LCD COMMANDS PIN

.EQU LCD_RS = 0			;LCD RS
.EQU LCD_RW = 1			;LCD RW
.EQU LCD_EN = 2			;LCD EN

//MACROS
.MACRO OUTI
	LDI R17, @1
	OUT @0, R17
.ENDMACRO

//OUTPUTS DATA THROUGH R20
.MACRO WRITE
	LDI R20, @1
	CALL @0
.ENDMACRO

//GPR JOBS
/*
R16 = INIT REG - MSG POINTER
R17 = OUT REG & SUBROUTINE REG
R18 = HIGH SCORE REG
R19 = BIRD LOCATION REG (1=HIGH, 0=LOW)
R20 = COMMANDS AND DATA WRITES
R21 = OBJ COUNTER
R22 = EOR BIRD REG & COPY REG
R23 = 
R24 = TOP BUTTON (SWITCH MENU)
R25 = 
R26 = XL - ROTATE TOP RIGHT
R27 = XH - ROTATE TOP LEFT
R28 = YL - ROTATE BOTTOM RIGHT
R29 = YH - ROTATE BOTTOM LEFT
R30 = ZL - EEPROM & FRAME RATE LOW
R31 = ZH - EEPROM & FRAME RATE HIGH
*/

//INIT EEPROM:
.ESEG
.ORG $0050
HIGH_SCORE:	.DB	0x00	//INITIALIZE HIGH SCORE TO 0
.CSEG	;return to code memory

//INTERRUPT VECTOR TABLE
.ORG $0000								// LOCATION FOR INTERRUPT RESET LOCATION (TABLE 10.1 IN TBOOK)
	JMP MAIN
.ORG $0002								//LOCATION FOR EXT INT 0 (TABLE 10.1 IN TBOOK)
	JMP BOTTOM_BUTTON
.ORG $0004								//LOCATION FOR EXT INT 1 (TABLE 10.1 IN TBOOK)
	JMP TOP_BUTTON
.ORG $0016								//COMPARE A TIMER 1 MATCH(TABLE 10.1 IN TBOOK)
	RJMP TIMEOUT

.ORG $0100
MAIN:
	//CONFIGURATION PHASE - RUNS ONCE
	//INIT STACK
	LDI R16, HIGH(RAMEND)
	OUT SPH, R16
	LDI R16, LOW(RAMEND)
	OUT SPL, R16

	//INIT I/O
	LDI R16, 0XF0
	OUT LCD_DDDR, R16		;LCD DATA PORT OUTPUT - HIGH NIBBLE, LOW NIBBLE INPUT
	SWAP R16
	OUT LCD_DPRT, R16		;PORT D LOW NIBBLE PULLUP ENABLE, INIT OUTPUTS TO 0
	OUT LCD_CDDR, R16		;LCD COMMAND PORT OUTPUT - LOW NIBBLE

	//CONFIGURE INITIAL TIMER/INTERRUPT BEHAVIORS
	CLR R16
	OUT TCNT0, R16
	OUT TCCR0A, R16					//NORMAL MODE
	STS TCCR1A, R16					//NORMAL OPERATION
	STS TCCR1B, R16					//TIMER OFF
	LDI R16, (1<<ISC01 | 1<<ISC11)	//CONFIGURE BUTTONS FOR FALLING EDGE INTERRUPTS
	STS EICRA, R16
	LDI R16, 1<<INT1				//ENABLE EXTERNAL INTERRUPT 1, TOP BUTTON.
	OUT EIMSK, R16
	SEI								//GLOBAL INTERRUPTS ENABLED
	
	
	//BEGIN CONFIGURING THE LCD
	CBI LCD_CPRT, LCD_EN	;LCD_EN = 0
	CALL DELAY_2MS			;WAIT FOR POWER ON
	WRITE CMD, 0x33			;INIT LCD 4BIT MODE
	CALL DELAY_2MS
	WRITE CMD, 0x32			;INIT LCD 4BIT MODE
	CALL DELAY_2MS
	WRITE CMD, 0X28			//5X7 MATRIX, 2 LINES
	CALL DELAY_2MS
	WRITE CMD, 0X0E			//DISPLAY ON CURSOR ON
	CALL DELAY_2MS

	//CREATE CUSTOM CHARS
    //INITIALIZE AND DRAW THE ORIGINAL BIRD TO CGRAM (accessible with WRITE DATA, 0)
    WRITE CMD, 0x40 //SET ADDRESS TO FIRST CGRAM ADDR.
    CALL DELAY_2MS
    WRITE DATA, 0x0E //01110: ADD IN EACH BIT ROW OF THE 5X7 MATRIX FOR CUSTOM CHARS
    CALL DELAY_2MS 
    WRITE DATA, 0x0D //01101
    CALL DELAY_2MS
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS 
    WRITE DATA, 0x06 //00110
    CALL DELAY_2MS
    WRITE DATA, 0x1E //11110
    CALL DELAY_2MS 
    WRITE DATA, 0x1E //11110
    CALL DELAY_2MS
    WRITE DATA, 0x0C //01100
    CALL DELAY_2MS

    //DRAW THE LOWER PIPE TO CGRAM PART 2 (accessible with WRITE DATA, 1)
    WRITE CMD, 0x48 //SET ADDRESS TO SECOND CGRAM ADDR.
    CALL DELAY_2MS
    WRITE DATA, 0x0E //01110: ADD IN EACH BIT ROW OF THE 5X7 MATRIX FOR CUSTOM CHARS
    CALL DELAY_2MS 
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS 
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS 
    WRITE DATA, 0x1F //11111
    CALL DELAY_2MS
    WRITE DATA, 0x1F //11111
    CALL DELAY_2MS

    //DRAW THE UPPER PIPE TO CGRAM PART 3 (accessible with WRITE DATA, 2)
    WRITE CMD, 0x51 //SET ADDRESS TO THIRD CGRAM ADDR.
    CALL DELAY_2MS
    WRITE DATA, 0x1F //11111: ADD IN EACH BIT ROW OF THE 5X7 MATRIX FOR CUSTOM CHARS
    CALL DELAY_2MS 
    WRITE DATA, 0x1F //11111
    CALL DELAY_2MS
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS 
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS 
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS
    WRITE DATA, 0x0E //01110
    CALL DELAY_2MS

	//GAME CODE LOOP\\
STARTSCREEN:
	//REFRESH THE GAME VIEW
	WRITE CMD, CLR_SCRN		//CLEAR SCREEN
	CALL DELAY_2MS			
	WRITE CMD, CURSRGHT		//SHIFT CURSOR RIGHT
	CALL DELAY_2MS

	//WRITE GAME NAME TO LCD
	LDI ZH, HIGH(GAME_STR<<1)
	LDI ZL, LOW(GAME_STR<<1)
	CALL WRITE_STR

	//WRITE "HIGH SCORE:" TO LCD
	WRITE CMD, BOT_CELL		//FORCE CURSOR TO 2ND LINE
	CALL DELAY_2MS			//WAIT 2 ms
	LDI ZH, HIGH(SCORE_STR<<1)
	LDI ZL, LOW(SCORE_STR<<1)
	CALL WRITE_STR

	//GET THE CURRENT HIGH SCORE FROM EEPROM
	LDI ZH, HIGH(HIGH_SCORE)
	LDI ZL, LOW(HIGH_SCORE)
	CALL LOAD_FROM_ROM			//LOAD R18 WITH EEPROM HIGH SCORE

	/*
	//REINIT EEPROM TO 0 -UNCOMMENT TO REINIT EEPROM TO 0
	CLR R18
	CALL STORE_TO_ROM
	RELOAD:	RJMP RELOAD
	*/

	//CONVERT HS IN R18 INTO ASCII
		//ONES PLACE
	CALL MOD10		//R18 = QUOTIENT, R20 = REMAINDER
	ORI R20, 0X30	//SET ASCII BITS FOR 3DIG HIGH SCORE
	STS ONES, R20
		//TENS
	CALL MOD10
	ORI R20, 0X30
	STS TENS, R20
		//HUNDREDS
	CALL MOD10
	ORI R20, 0X30
	STS HUNDREDS, R20

	//WRITE TO SCREEN
	LDS R20, HUNDREDS
	CALL DATA
	LDS R20, TENS
	CALL DATA
	LDS R20, ONES
	CALL DATA

	//ASSURE THAT THE BUTTON HAS NO FLOATING VALUE
	CLR R24
	WAITFORGAME:			//ONLY ADVANCE TO GAME WHEN BUTTON IS PRESSED
		TST R24
		BREQ WAITFORGAME
		CLR R24				//RESET BUTTON REG
	
GAME_INIT:
	//DISBALE SKIP
	OUTI EIMSK, 1<<INT0
	//CLEAR SCREEN
	WRITE CMD, CLR_SCRN
	CALL DELAY_2MS
	WRITE CMD, CURSRGHT
	CALL DELAY_2MS

	//CONFIGURE STARTUP REGISTERS
	CLR R18					//INIT SCORE TO 0
	CLR R19					//SET BIRD TO BOTTOM ROW
	LDI R21, 5				//CONFIGURE INIT PIPE SPAWN RATE (N * TIMER INTERRUPTS)
	CLR XH
	CLR XL
	CLR YH
	CLR YL
	//CONFIG TIMER1
	CLR R16
	STS TCNT1H, R16		//LOADING 0 CREATES LONGEST DELAY
	STS TCNT1L, R16
	LDI R16, 1<<OCIE1A	//ENABLE OUTPUT COMPARE INERRUPTS
	STS TIMSK1, R16
	
	//CREATE INIT_DELAY 1 SEC
	LDI ZH, HIGH(62500)	//TAKES 250 INTERRUPTS TO SET TO 0
	LDI ZL, LOW(62500)
	STS OCR1AH, ZH
	STS OCR1AL, ZL

	WRITE CMD, BOT_CELL
	CALL DELAY_2MS
	WRITE DATA, 0			//DRAW BIRD

	CALL DELAY_2MS

	//START THE TIMERS
	LDI R16, CLK
	STS TCCR1B, R16			//CTC MODE WITH PRESCALE 256
	LDI R16, 1				//NO PRESCALE
	OUT TCCR0B, R16
	
GAME_LOOP:
	//CHECK FOR FAILURE IN INTERRUPTS, EXIT IF COLLISION OCCURS OR BUTTON IS PRESSED
	TST R24
	BREQ GAME_LOOP

GAME_OVER:
	//DISABLE GAME INTERRUPTS
	LDI R16, 1<<INT1	//DISABLE EXTERNAL INTERUPT 0; LEAVE TOP ENABLED
	OUT EIMSK, R16
	//STOP TIMER + TIMER INTERRUPTS
	CLR R16
	STS TCCR1B, R16		//CLOCK OFF
	STS TIMSK1, R16		//DISABLE TIMER1 INTERRUPTS

	//COPY PLAYER SCORE TO R16
	MOV R22, R18

	//HANDLE PLAYER SCORE
		//ONES
	CALL MOD10		//R18 = QUOTIENT, R20 = REMAINDER
	ORI R20, 0X30	//SET ASCII BITS FOR 3DIG HIGH SCORE
	STS ONES, R20
		//TENS
	CALL MOD10
	ORI R20, 0X30
	STS TENS, R20
		//HUNDREDS
	CALL MOD10
	ORI R20, 0X30
	STS HUNDREDS, R20

	//DISPLAY PLAYER SCORE
	WRITE CMD, CLR_SCRN		//CLEAR SCREEN
	CALL DELAY_2MS			//WAIT 2 ms
	WRITE CMD, CURSRGHT		//SHIFT CURSOR RIGHT

	//WRITE "GAME OVER"
	LDI ZH, HIGH(END_GAME_STR<<1)
	LDI ZL, LOW(END_GAME_STR<<1)
	CALL WRITE_STR
	
	//WRITE "YOUR SCORE:" TO LCD
	WRITE CMD, BOT_CELL			//FORCE CURSOR TO 2ND LINE
	CALL DELAY_2MS			//WAIT 2 ms
	LDI ZH, HIGH(END_GAME_SCORE_STR<<1)
	LDI ZL, LOW(END_GAME_SCORE_STR<<1)
	CALL WRITE_STR
	
	//WRITE SCORE TO SCREEN	- SCORE = HOW MANY OBSTACLES GENERATED BEFORE LOSS
	LDS R20, HUNDREDS
	CALL DATA
	LDS R20, TENS
	CALL DATA
	LDS R20, ONES
	CALL DATA

	//COLLECT HIGH SCORE
	LDI ZH, HIGH(HIGH_SCORE)
	LDI ZL, LOW(HIGH_SCORE)
	//R22 = NEW SCORE, LOAD OLD INTO R18
	CALL LOAD_FROM_ROM
	CLR R24				//RESET BUTTON REG

	//COMPARE SCORES
	CP R22, R18
	BRLO GAME_OVER_WAIT	//NEW SCORE WAS NOT GREATER
	//REWRITE EEPROM WITH NEW SCORE
	MOV R18, R22
	CALL STORE_TO_ROM
	
	//WAIT AT END SCREEN BEFORE RETURNING TO START
	GAME_OVER_WAIT:
		TST R24
		BREQ GAME_OVER_WAIT
		RJMP STARTSCREEN
	
//SUBROUTINES SECTION\\

GENERATE_PIPE:
	//FIRST, GET A RANDOM NUMBER (1 OR 0)
	IN R16, TCNT0
	ANDI R16, 1	//GET LSB
	BRNE DRAW_HIGH
	//APPEND THE 1 TO THE ROTATING REGISTERS LOW EDGE
	DRAW_LOW:
		ORI YL, 1
		RJMP DONE
	DRAW_HIGH:
		ORI XL, 1
	DONE:
	RET

/////////////////////////////////////////////////////
CMD:
	CBI LCD_CPRT, LCD_RS		//RS = 0 FOR COMMAND
	RJMP LCD_SEND

DATA:
	SBI LCD_CPRT, LCD_RS		//RS = 1 FOR DATA
	RJMP LCD_SEND

//SENDS DATA/CMD TO LCD DISPLAY
LCD_SEND:
	CALL LCD_SEND_2
	SWAP R20
	CALL LCD_SEND_2
	RET
	LCD_SEND_2:
		MOV R17, R20
		ANDI R17,0XF0	//send the high nibble
		ORI R17,0X0F	//KEEP PULLUPS ACTIVE
		OUT LCD_DPRT, R17
		CBI LCD_CPRT,	LCD_RW	//RW=0 FOR WRITE
		SBI LCD_CPRT, LCD_EN	//EN=1 FOR PULSE
		CALL SDELAY
		CBI LCD_CPRT, LCD_EN	//FALLING EDGE
		CALL DELAY_100us
		RET
/////////////////////////////////////////////////////
SDELAY:
	NOP
	NOP
	RET

DELAY_100us:
	PUSH R17	;STORE VALUE OF R17
	LDI R17, 120
	DR0: CALL SDELAY
		DEC R17
		BRNE DR0
	POP R17		;RELOAD R17
	RET

DELAY_2MS:
	PUSH R17
	LDI R17, 20
	LDR0: CALL DELAY_100us
		DEC R17
		BRNE LDR0
	POP R17
	RET
////////////////////////////////////////////////////
//LOAD R18 WITH THE CONTENTS OF LOCATION Z OF EEPROM
LOAD_FROM_ROM:
	SBIC EECR, EEPE
	RJMP LOAD_FROM_ROM
	OUT EEARH, ZH
	OUT EEARL, ZL
	SBI EECR, EERE	;SET READ ENABLE TO ONE
	IN R18, EEDR	;LOAD EEPROM DATA REG TO R18
	RET
//STORE R18 INTO LOCATION Z OF EEPROM
STORE_TO_ROM:
	SBIC EECR, EEPE
	RJMP STORE_TO_ROM
	OUT EEARH, ZH
	OUT EEARL, ZL
	OUT EEDR, R18
	SBI EECR, EEMPE	;SET MASTER WRITE ENABLE TO ONE
	SBI EECR, EEPE	;WRITE EEDR INTO EEPROM
	RET

//Divide a number in R18 by 10, R18 is the quotient, R20 is remainder
MOD10:
	LDI R20, 0x00		; load 0 into GPR 20
	LDI R16, 10			; used for subtraction of 10
	divide: 
		INC R20			; Increment R20 to show one subtraction step
		SUB R18, R16	; Number - 10, store result in R16
		BRSH divide		; branch if the number is not negative (Carry bit returns 1 if rollunder 0)
	
	DEC R20				; After the loop above, the output would be 1 more than intended
	ADD R18, R16		; Return the remainder from the subtractions by undoing the last subtraction!

	MOV R21, R20		;move the quotient into temp GPR
	MOV R20, R18		;move remainder into R20
	MOV R18, R21		;Move quotient into R18
	CLR R21				;Clean Temp GPR
	RET					;return to main program

//WRITES A STRING TO THE LCD BASED ON THE Z LOCATION
WRITE_STR:
	LPM R20, Z+
	CPI R20, 0
	BREQ MSGEND //JUMP TO END WHEN 0 IS MET
	CALL DATA
	RJMP WRITE_STR
	MSGEND:
	RET

//ONLY HAPPENS IF NO COLLISION OCCURED
DRAW_ROWX:
	PUSH R17	//STORE VALUE
	WRITE CMD, TOP_CELL
	CALL DELAY_2MS

	LDI R16, 8	//ROL FULL ROTATION FOR NO BIRD
	CLC
	//DRAW BIRD FIRST IF THERES A BIRD IN X
	TST R19
	BREQ DRAW_PIPESX		//DRAWS BIRD IF 1=HIGH
		
		WRITE CMD, TOP_CELL	//FIRST ROW TOP
		WRITE DATA, 0		//DRAW THE BIRD
		CALL DELAY_100us
		ROL XH				//CLEARS THE BIRD FROM THE VECTOR
		DEC R16				//DO ONE LESS ROTATION

	//DRAW PIPES
	DRAW_PIPESX:
		LOOPXH: 
			ROL XH
			BRCS PIPEXH	//DRAW A PIPE IF 1
			SPACEXH:
				WRITE DATA, ' '
				RJMP CHECKXH
			PIPEXH:
				WRITE DATA, 2
			CHECKXH: 
			DEC R16
			BRNE LOOPXH
		ROL XH		//FULL RESET
		LDI R16, 8	//RESET PIPE FULL ROTATION
		CLC
		LOOPXL:
			ROL XL
			BRCS PIPEXL	//DRAW A PIPE IF 1
			SPACEXL:
				WRITE DATA, ' '
				RJMP CHECKXL
			PIPEXL:
				WRITE DATA, 2
			CHECKXL: 
			DEC R16
			BRNE LOOPXL
		ROL XL
	POP R17	//RESTORE VALUE
	RET

DRAW_ROWY:
	PUSH R17	//STORE VALUE
	WRITE CMD, BOT_CELL
	CALL DELAY_2MS
	LDI R16, 8	//ROL FULL ROTATION FOR NO BIRD
	CLC
	//DRAW BIRD FIRST IF THERES A BIRD IN X
	TST R19
	BRNE DRAW_PIPESY		//DRAWS BIRD IF 0=LOW
		
		WRITE CMD, BOT_CELL	//FIRST ROW TOP
		WRITE DATA, 0		//DRAW THE BIRD
		ROL YH				//CLEARS THE BIRD FROM THE VECTOR
		DEC R16				//DO ONE LESS ROTATION

	//DRAW PIPES
	DRAW_PIPESY:
		LOOPYH: 
			ROL YH
			BRCS PIPEYH	//DRAW A PIPE IF 1
			SPACEYH:
				WRITE DATA, ' '
				RJMP CHECKYH
			PIPEYH:
				WRITE DATA, 1
			CHECKYH: 
			DEC R16
			BRNE LOOPYH
		ROL YH
		LDI R16, 8	//RESET PIPE FULL ROTATION
		CLC
		LOOPYL:
			ROL YL
			BRCS PIPEYL	//DRAW A PIPE IF 1
			SPACEYL:
				WRITE DATA, ' '
				RJMP CHECKYL
			PIPEYL:
				WRITE DATA, 1
			CHECKYL: 
			CALL DELAY_100us
			DEC R16
			BRNE LOOPYL
			ROL YL
		POP R17	//RESTORE VALUE
		RET

////////////////////////////////////////////////////////////
TOP_BUTTON:
	INC R24			//MOVES THROUGH PROGRAM
	RETI

BOTTOM_BUTTON:
	LDI R22, 1
	EOR R19, R22	//CHANGE THE STATE OF R19 SO BIRD IS DRAWN EVERY FRAME ON CORRECT ROW
	CALL DRAW_ROWX	//QUICKLY REDRAW ROWS
	CALL DRAW_ROWY
	CLR R24			//PROTECT AGAINST FALSE ENDS
	RETI

//TIMER1 OCA INTERRUPT
TIMEOUT:
	//DEC OBJ COUNTER
	DEC R21
	//SHIFT LCD DISPLAY LEFT
	BACKEND:
		CLC
		ROL XL
		ROL XH
		CLC
		ROL YL
		ROL YH
	//GENERATE A PIPE IF OBSTACLE COUNTER REACHES 0
	TST R21
	BRNE COLLISION_CHECK
	//INCREMENT THE SCORE
	INC R18
	CALL GENERATE_PIPE
	//CHECK BIRD LOCATION FOR CAMPING
    TST R19
    BRNE RAND_HIGH
    MOV R21, YL
    RJMP RESET
    //SAMPLE FROM SAME ROW TO DETER "CAMPING" A ROW
    RAND_HIGH:
    MOV R21, XL
    RESET:
    ANDI R21, 0X0F    //SAMPLE LOWER NIBBLE, RANDOMIZE PIPE WIDTH
    ORI R21, 3        //MINIMUM PIPE RATE RANGE {3, 7, 11}
	
	SUBI ZL, LOW(625)	//DECREMENT THE DELAY
	SBCI ZH, HIGH(625)	//TAKES THE CARRY AWAY AS NEEDED

	//LOAD THE COUNTER REGISTERS
	CLR R16
	STS TCCR1B, R16	//STOP THE COUNTER TEMPORARILY
	STS OCR1AH, ZH
	STS OCR1AL, ZL
	STS TCNT1H, R16	//RESET TIMER
	STS TCNT1L, R16
	LDI R16, CLK	//ENABLE TIMER
	STS TCCR1B, R16

	//COLLISION CHECK
	COLLISION_CHECK:
	MOV R16, XH	//COPY PIPE DATA
	MOV R17, YH	
	TST R19		//GET POSITION OF BIRB
	BREQ CHECK_LOW
	CHECK_HIGH:
		ANDI R16, 0B10000000	//CHECK MSB FOR OBSTACLE, 0 IF NONE, 1 IF COLLIDE
		BREQ NO_COLLIDE
		RJMP COLLIDE
	CHECK_LOW:
		ANDI R17, 0B10000000
		BREQ NO_COLLIDE		//IF NOT EQUAL, END CHECK
	COLLIDE:	INC R24	    //SET R24 TO END GAME
				RETI		//END THE GAME WITHOUT REDRAW

	//REDRAW THE GAME IF NO COLLISION OCCURED
	NO_COLLIDE:
		CALL DRAW_ROWX
		CALL DRAW_ROWY
		CLR R24
		RETI

////////////////////////////////////////////////////////////
//STRINGS TO DISPLAY
GAME_STR: .DB "SLOPPY BIRB",0
SCORE_STR: .DB "HIGH SCORE:",0
//STRINGS TO DISPLAY AT GAME END
END_GAME_STR: .DB "GAME OVER",0
END_GAME_SCORE_STR: .DB "YOUR SCORE:",0